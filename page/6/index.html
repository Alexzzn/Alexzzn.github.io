<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MyBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的博客分享">
<meta property="og:type" content="website">
<meta property="og:title" content="MyBlog">
<meta property="og:url" content="https://Alexzzn.github.io/page/6/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="og:description" content="我的博客分享">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MyBlog">
<meta name="twitter:description" content="我的博客分享">
  
    <link rel="alternate" href="/atom.xml" title="MyBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Alexzzn.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">博客</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS/Promise-iOS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/Promise-iOS/" class="article-date">
  <time datetime="2018-07-18T09:57:26.468Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/Promise-iOS/">Promise-iOS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><code>`</code>swift<br>//<br>//  MyPromise.swift<br>//  WeexApp<br>//<br>//  Created by zzn on 2017/4/28.<br>//  Copyright © 2017年 zzn. All rights reserved.<br>//</p>
<p>import UIKit<br>import PromiseKit</p>
<p>class MyPromise {</p>
<pre><code>init() {
    setup()
}

func setup() {

    login(userName: &quot;lishi&quot;, pwd: &quot;1234&quot;).then{self.getFriend(id: $0.id)}.then{ (list) -&gt; Void in
        print(list.enumerated())
    }.catch { (err) in
        print(err)
    }
}


//模拟登陆
func login(userName:String,pwd:String) -&gt; Promise&lt;Person&gt; {

    //requestNet
    let isAcc = true
    let person = Person()

    return Promise{ fulfile,reject in

        if isAcc {
            person.name = userName
            person.pwd = pwd
            fulfile(person)
        } else {
            reject(MyError.init(info: &quot;HAHA&quot;))
        }
    }

}
//模拟获取好友列表
func getFriend(id:String?) -&gt; Promise&lt;[Person]&gt;  {


    //requestNet

    let perList = [Person(),Person()]
    return Promise{ fulfile,reject in

        if id?.isEmpty == true {
            reject(MyError.init(info: &quot;HAHA&quot;))
        }

        fulfile(perList)
    }
}
</code></pre><p>}</p>
<p>class Person {</p>
<pre><code>var name:String?
var pwd:String?
var id = &quot;2332&quot;

init() {
    name = &quot;zhanshan&quot;
    pwd = &quot;11&quot;
}
</code></pre><p>}</p>
<p>struct MyError:Error {</p>
<pre><code>var info:String
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/Promise-iOS/" data-id="cjjs94x0f00369t537apsh29w" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/GCD 重点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/GCD 重点/" class="article-date">
  <time datetime="2018-07-18T09:57:26.467Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/GCD 重点/">GCD 重点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="DCD"><a href="#DCD" class="headerlink" title="DCD"></a>DCD</h4><p><code>`</code>c++</p>
<pre><code>#pragma 信号量
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_async(queue, ^{

    // 相当于加锁
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;执行任务1&quot;);
    // 相当于解锁
    dispatch_semaphore_signal(semaphore);
});

dispatch_async(queue, ^{

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;执行任务2&quot;);
    dispatch_semaphore_signal(semaphore);
});

dispatch_async(queue, ^{

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;执行任务3&quot;);

    dispatch_async(dispatch_get_global_queue(0, 0), ^{

        [NSThread sleepForTimeInterval:3];
        NSLog(@&quot;异步执行任务3&quot;);
        dispatch_semaphore_signal(semaphore);
    });

});

dispatch_async(queue, ^{

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;执行任务4&quot;);
    dispatch_semaphore_signal(semaphore);
});

#pragma barrier
dispatch_queue_t queue2 = dispatch_queue_create(&quot;zzn.com.01&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue2, ^{
    // doSomething()
    [NSThread sleepForTimeInterval:2];
    NSLog(@&quot;barrier:执行任务1&quot;);
});
dispatch_barrier_async(queue2, ^{
    NSLog(@&quot;barrier:执行任务2&quot;);
});

#pragma group
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue3 = dispatch_queue_create(&quot;zzn.com.03&quot;, DISPATCH_QUEUE_CONCURRENT);

//
dispatch_group_async(group, queue3, ^{

    [NSThread sleepForTimeInterval:2];
    NSLog(@&quot;group:执行任务1&quot;);
});

// 等同 dispatch_group_async
dispatch_async(queue3, ^{

    dispatch_group_enter(group);
    [NSThread sleepForTimeInterval:2];
    dispatch_group_leave(group);
    NSLog(@&quot;group:执行任务2&quot;);
});


dispatch_group_notify(group, queue3, ^{
    NSLog(@&quot;group:执行任务3&quot;);
});
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/GCD 重点/" data-id="cjjs94x08002v9t5346fe9vjc" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/Facebook，Twitter分享整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/Facebook，Twitter分享整理/" class="article-date">
  <time datetime="2018-07-18T09:57:26.466Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/Facebook，Twitter分享整理/">Facebook，Twitter分享整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h5 id="facebook-分享"><a href="#facebook-分享" class="headerlink" title="facebook 分享"></a>facebook 分享</h5><blockquote>
<p>分享类型要确定，如果是FBSDKShareLinkContent（链接），要确定好link的地址正确，否则无法弹出分享框，很难排查，Twitter也类似。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/Facebook，Twitter分享整理/" data-id="cjjs94x09002x9t53mb9043wd" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/swift4.1更新" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/swift4.1更新/" class="article-date">
  <time datetime="2018-07-18T09:57:26.465Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/swift4.1更新/">swift4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h5 id="条件一致性"><a href="#条件一致性" class="headerlink" title="条件一致性"></a>条件一致性</h5><p>如果数组、字典或者可选类型的元素类型遵循Equatable,这可以做相同的操作</p>
<h4 id="合并Equatable和Hashable协议的一致性"><a href="#合并Equatable和Hashable协议的一致性" class="headerlink" title="合并Equatable和Hashable协议的一致性"></a>合并Equatable和Hashable协议的一致性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// swift4</span><br><span class="line">struct Person: Equatable &#123;</span><br><span class="line">  static func == (lhs: Person, rhs: Person) -&gt; Bool &#123;</span><br><span class="line">    return lhs.firstName == rhs.firstName &amp;&amp;</span><br><span class="line">           lhs.lastName == rhs.lastName &amp;&amp;</span><br><span class="line">           lhs.birthDate == rhs.birthDate &amp;&amp;</span><br><span class="line">           ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// swift4.1</span><br><span class="line">如果 firstName等属性全部遵循了Equatable和Hashable，这可以不用实现 == 运算符</span><br></pre></td></tr></table></figure>
<h4 id="在JSON编码"><a href="#在JSON编码" class="headerlink" title="在JSON编码"></a>在JSON编码</h4><blockquote>
<p>在Swift 4.1中，苹果给JSONDecoder引入了一个属性keyDecodingStrategy；对应的JSONEncoder引入了一个属性keyEncodingStrategy。这样我们就不需要设置定义CodingKeys了。只需要在decoding的时候把keyDecodingStrategy设置为.convertFromSnakeCase；在encoding的时候把keyEncodingStrategy设置为.convertToSnakeCase。所以上面的代码我们可以改为：</p>
</blockquote>
<h4 id="哈希化索引类型-Index-Types-Hashable"><a href="#哈希化索引类型-Index-Types-Hashable" class="headerlink" title="哈希化索引类型 (Index Types Hashable)"></a>哈希化索引类型 (Index Types Hashable)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="keyword">let</span> f1 = \[int].[<span class="number">0</span>]</span><br><span class="line">number[keyPath:f1]</span><br></pre></td></tr></table></figure>
<h4 id="支持关联类型的递归约束"><a href="#支持关联类型的递归约束" class="headerlink" title="支持关联类型的递归约束"></a>支持关联类型的递归约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//swift4</span><br><span class="line">protocol Foo &#123;</span><br><span class="line">    associatedtype SomeType: Bar</span><br><span class="line">&#125;</span><br><span class="line">//swift4.1</span><br><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype SubSequence: Sequence</span><br><span class="line">        where Iterator.Element == SubSequence.Iterator.Element, SubSequence.SubSequence == SubSequence</span><br><span class="line"></span><br><span class="line">    func dropFirst(_ n: Int) -&gt; Self.SubSequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平台有关"><a href="#平台有关" class="headerlink" title="平台有关"></a>平台有关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#if os(iOS) || os(tvOS)</span><br><span class="line">  import UIKit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if canImport(UIKit)</span><br><span class="line">  import UIKit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if (arch(i386) || arch(x86_64)) &amp;&amp; (!os(macOS))</span><br><span class="line">    print(&quot;Simulator&quot;)</span><br><span class="line">#else</span><br><span class="line">    print(&quot;Device&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if targetEnvironment(simulator)</span><br><span class="line">    print(&quot;Simulator&quot;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/swift4.1更新/" data-id="cjjs94x18004c9t533m9tp2c8" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/闭包小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/闭包小结/" class="article-date">
  <time datetime="2018-07-18T09:57:26.463Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/闭包小结/">闭包小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void(^closure1)();</span><br><span class="line">void(^closure2)();</span><br><span class="line"></span><br><span class="line">__weak __typeof (self)weakSelf = self;</span><br><span class="line">closure1 = ^() &#123;</span><br><span class="line"></span><br><span class="line">	__strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">	[strongSelf doSomething()];</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">closure();</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/5db1579c5454" target="_blank" rel="noopener">地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/闭包小结/" data-id="cjjs94x1l004u9t53ed93uu6i" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/FMDB_OC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/FMDB_OC/" class="article-date">
  <time datetime="2018-07-18T09:57:26.462Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/FMDB_OC/">FMDB_OC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="fmdb-的使用"><a href="#fmdb-的使用" class="headerlink" title="fmdb 的使用:"></a>fmdb 的使用:</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#获取path:</span><br><span class="line"><span class="type">NSArray</span> *dbpath = [[<span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSDocumentDirectory</span>, <span class="type">NSUserDomainMask</span>, <span class="type">YES</span>) <span class="type">FristObject</span>] stringByAppendingPathComponent: @<span class="string">"mydatabase.db"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//creat  db</span></span><br><span class="line"><span class="type">FMDataBase</span> *db =  [<span class="type">FMDatabase</span> databaseWithPath:dbPath] ;</span><br><span class="line"><span class="comment">//creat table</span></span><br><span class="line">[db executeUpdate:@<span class="string">"CREATE TABLE PersonList if no exists(Name text, Age integer, Sex integer, Phone text, Address text, Photo blob)"</span>];</span><br><span class="line"><span class="comment">// creat into</span></span><br><span class="line">[db executeUpdate:@<span class="string">"INSERT INTO PersonList (Name, Age, Sex, Phone, Address, Photo) VALUES (?,?,?,?,?,?)"</span>,@<span class="string">"Jone"</span>, [<span class="type">NSNumber</span> numberWithInt:<span class="number">20</span>], [<span class="type">NSNumber</span> numberWithInt:<span class="number">0</span>], @“<span class="number">091234567</span>”, @“<span class="type">Taiwan</span>”, [<span class="type">NSData</span> dataWithContentsOfFile: filepath]];</span><br><span class="line"><span class="comment">//update</span></span><br><span class="line">[db executeUpdate:@<span class="string">"UPDATE PersonList SET Age = ? WHERE Name = ?"</span>,[<span class="type">NSNumber</span> numberWithInt:<span class="number">30</span>],@“<span class="type">John</span>”];</span><br><span class="line"></span><br><span class="line"><span class="comment">//search</span></span><br><span class="line"><span class="type">FMResultSet</span> *rs = [db executeQuery:@<span class="string">"SELECT Name, Age, FROM PersonList"</span>];</span><br><span class="line"><span class="keyword">while</span>([rs next]) &#123;</span><br><span class="line"><span class="type">NSString</span> *name = [rs stringForColumn:@<span class="string">"Name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"> [db executeUpdate:@<span class="string">"DROP TABLE IF EXISTS PersonList;"</span>];</span><br><span class="line"></span><br><span class="line">[db executeUpdateWithForamt:@<span class="string">"insert into table(name,age) values(%@,%d);"</span>_name,_age]</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程</span></span><br><span class="line"><span class="type">NSString</span> *path=<span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSDocumentDirectory</span>, <span class="type">NSUserDomainMask</span>, <span class="type">YES</span>)[<span class="number">0</span>];</span><br><span class="line">path=[path stringByAppendingPathComponent:@<span class="string">"test.sqlite"</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">FMDatabaseQueue</span> * queue=[<span class="type">FMDatabaseQueue</span> databaseQueueWithPath:path];</span><br><span class="line">[queue inDatabase:^(<span class="type">FMDatabase</span> *db) &#123;</span><br><span class="line"><span class="type">NSString</span> *str = @<span class="string">"create table if not exists t_book(id integer,name varchar)"</span>;</span><br><span class="line"><span class="type">BOOL</span> c1= [db executeUpdate:create];</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"> [queue inDatabase:^(<span class="type">FMDatabase</span> *db) &#123;</span><br><span class="line">            <span class="type">NSString</span> * insertSql=@<span class="string">"insert into t_book(id,name) values(?,?)"</span>;</span><br><span class="line">          <span class="comment">//插入语句1</span></span><br><span class="line">            bool inflag=[db executeUpdate:insertSql,@(<span class="number">2</span>),@<span class="string">"admin"</span>];</span><br><span class="line">           <span class="keyword">if</span>(inflag)&#123;</span><br><span class="line">               <span class="type">NSLog</span>(@<span class="string">"插入成功"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">    [queue inDatabase:^(<span class="type">FMDatabase</span> *db) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">FMResultSet</span> * data=[db executeQuery:@<span class="string">" select * from t_book "</span>];   </span><br><span class="line">        <span class="keyword">while</span> (data.next) &#123;</span><br><span class="line">            int ids=[data intForColumn:@<span class="string">"id"</span>];</span><br><span class="line">            <span class="type">NSString</span> *name=[data stringForColumn:@<span class="string">"name"</span>]; </span><br><span class="line">        &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/FMDB_OC/" data-id="cjjs94x05002q9t53cnjwhy1b" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/Runtime_OC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/Runtime_OC/" class="article-date">
  <time datetime="2018-07-18T09:57:26.461Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/Runtime_OC/">Runtime_OC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="runtime-oc"><a href="#runtime-oc" class="headerlink" title="runtime oc"></a>runtime oc</h3><blockquote>
<p>参考地址：<a href="http://www.jianshu.com/p/f900de4a1495" target="_blank" rel="noopener">http://www.jianshu.com/p/f900de4a1495</a></p>
</blockquote>
<blockquote>
<p>对象instance –&gt; 类class –&gt; 方法 –&gt; method(-&gt;sel -&gt; imp) –&gt;实现函数</p>
</blockquote>
<p>运行时机制最关键核心是objc_msgSend函数，通过给target（类）发送selecter（SEL）来传递消息，通过imp 指针找到method入口,找到匹配的IMP，指向实现的C函数。</p>
<p>运行时可以通过C操作函数，动态地创建修改类信息，动态绑定方法和重写实现，灵活地实现一些自定义功能</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- 类相关：</span><br><span class="line">           + 数据类型：<span class="class"><span class="keyword">class</span>，<span class="title">object</span>；</span></span><br><span class="line"><span class="class">                    - <span class="title">isa</span> 元类</span></span><br><span class="line"><span class="class">                    - <span class="title">superClass</span> 根类</span></span><br><span class="line"><span class="class">           + 操作函数:</span></span><br><span class="line"><span class="class">                     - <span class="title">class_</span>：</span></span><br><span class="line"><span class="class">                               + <span class="title">get</span>: 类名，父类; 实例变量，成员变量；属性；实例方法，类方法，方法实现；</span></span><br><span class="line"><span class="class">                               + <span class="title">copy</span>: 成员变量列表；属性列表；方法列表；协议列表；</span></span><br><span class="line"><span class="class">                               + <span class="title">add</span>: 成员变量；属性；方法；协议；</span></span><br><span class="line"><span class="class">                               + <span class="title">replace</span>：属性；方法；</span></span><br><span class="line"><span class="class">                               + <span class="title">respond</span>:响应方法判断（内省）</span></span><br><span class="line"><span class="class">                               + <span class="title">isMetaclass</span>:元类判断（内省）</span></span><br><span class="line"><span class="class">                               + <span class="title">conform</span>:遵循协议判断（内省）</span></span><br><span class="line"><span class="class">                     - <span class="title">objc_</span>：</span></span><br><span class="line"><span class="class">                               + <span class="title">get</span>: 实例变量；成员变量；类名；类；元类；关联对象；</span></span><br><span class="line"><span class="class">                               + <span class="title">copy</span>: 对象；类；类列表；协议列表；</span></span><br><span class="line"><span class="class">                               + <span class="title">set</span>: 实例变量；成员变量；类；类列表；协议；关联对象；</span></span><br><span class="line"><span class="class">                               + <span class="title">dispose</span>: 对象；</span></span><br><span class="line"><span class="class">                     - 动态创建/销毁类、对象</span></span><br><span class="line"><span class="class">   - 成员变量、属性相关：</span></span><br><span class="line"><span class="class">           + 数据类型：<span class="title">Ivar</span>；<span class="title">objc_property_t</span>；<span class="title">objc_property_attribute_t</span>；</span></span><br><span class="line"><span class="class">           + 操作函数：</span></span><br><span class="line"><span class="class">                      - <span class="title">ivar_</span>：</span></span><br><span class="line"><span class="class">                      - <span class="title">property_</span>：</span></span><br><span class="line"><span class="class">   - 方法消息相关：</span></span><br><span class="line"><span class="class">           + 数据类型：<span class="title">SEL</span>；<span class="title">IMP</span>; <span class="title">Method</span>；方法缓存</span></span><br><span class="line"><span class="class">           + 操作函数: </span></span><br><span class="line"><span class="class">                      - <span class="title">method_</span>：</span></span><br><span class="line"><span class="class">                               + <span class="title">invoke</span>: 方法实现的返回值；</span></span><br><span class="line"><span class="class">                               + <span class="title">get</span>: 方法名；方法实现；参数与返回值相关；</span></span><br><span class="line"><span class="class">                               + <span class="title">set</span>：方法实现；</span></span><br><span class="line"><span class="class">                               + <span class="title">exchange</span>：交换方法实现</span></span><br><span class="line"><span class="class">           + 方法调用：<span class="title">msgSend</span>函数（找到方法实现）</span></span><br><span class="line"><span class="class">           + 消息转发：</span></span><br><span class="line"><span class="class">                     - <span class="title">Method</span> <span class="title">Resolution</span></span></span><br><span class="line"><span class="class">                     - <span class="title">Fast</span> <span class="title">Forwarding</span></span></span><br><span class="line"><span class="class">                     - <span class="title">Normal</span> <span class="title">Forwarding</span></span></span><br><span class="line"><span class="class">   - 协议相关：</span></span><br><span class="line"><span class="class">           + 数据类型：<span class="title">Protocol</span>；</span></span><br><span class="line"><span class="class">           + 操作函数：</span></span><br><span class="line"><span class="class">                      - <span class="title">protocol_</span>：</span></span><br><span class="line"><span class="class">                               + <span class="title">get</span>: 协议；属性；</span></span><br><span class="line"><span class="class">                               + <span class="title">copy</span>：协议列表；属性列表；</span></span><br><span class="line"><span class="class">                               + <span class="title">add</span>：属性；方法；协议；</span></span><br><span class="line"><span class="class">                               + <span class="title">isEqual</span>：判断两协议等同；</span></span><br><span class="line"><span class="class">                               + <span class="title">comform</span>：判断是否遵循协议；</span></span><br><span class="line"><span class="class">   - 其他：类名；版本号；类信息；</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Method Swizzling;ISA Swizzling；</p>
</blockquote>
<p>运行时Runtime的一切都围绕这两个中心：类的动态配置 和 消息传递。通过操作函数来配置类信息，通过msgSend函数传递消息。<br> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> </span>&#123;</span><br><span class="line">    <span class="type">Class</span> isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !__OBJC2__</span><br><span class="line">    <span class="type">Class</span> super_class                       <span class="type">OBJC2_UNAVAILABLE</span>;  <span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line">    const char *name                        <span class="type">OBJC2_UNAVAILABLE</span>;  <span class="comment">// 类名</span></span><br><span class="line">    long version                            <span class="type">OBJC2_UNAVAILABLE</span>;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    long info                               <span class="type">OBJC2_UNAVAILABLE</span>;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line"></span><br><span class="line">    long instance_size                      <span class="type">OBJC2_UNAVAILABLE</span>;  <span class="comment">// 类的实例变量大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>            <span class="title">OBJC2_UNAVAILABLE</span>;  // 类的成员变量链表</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>   <span class="title">OBJC2_UNAVAILABLE</span>;  // 方法定义的链表</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                <span class="title">OBJC2_UNAVAILABLE</span>;  // 方法缓存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>    <span class="title">OBJC2_UNAVAILABLE</span>;  // 协议链表</span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125; <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>数据类型：<br>isa和super_class ：不同的类中可以有相同的方法（同一个类的方法不能同名，哪怕参数类型不同，后面解释…），所以要先确定是那个类。isa和super_class是找到实现函数的关键映射，决定找到存放在哪个类的方法实现。（isa用于自省确定所属类，super_class确定继承关系）。</p>
</blockquote>
<p>实例对象的isa指针指向类，类的isa指针指向其元类（metaClass）。对象就是一个含isa指针的结构体。类存储实例对象的方法列表，元类存储类的方法列表，元类也是类对象</p>
<p>文／楚天舒（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/f900de4a1495" target="_blank" rel="noopener">http://www.jianshu.com/p/f900de4a1495</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123;</span><br><span class="line">    <span class="type">Class</span> isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表由super_class指针找到父类的方法列表直至根类NSObject中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
</blockquote>
<p>文／楚天舒（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/f900de4a1495" target="_blank" rel="noopener">http://www.jianshu.com/p/f900de4a1495</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
<blockquote>
<p>class_：get: 类名，父类，元类；实例变量，成员变量；属性；实例方法，类方法，方法实现；<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line">const char * class_getName ( <span class="type">Class</span> cls );</span><br><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="type">Class</span> class_getSuperclass ( <span class="type">Class</span> cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line">size_t class_getInstanceSize ( <span class="type">Class</span> cls );</span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="type">Ivar</span> class_getInstanceVariable ( <span class="type">Class</span> cls, const char *name );</span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="type">Ivar</span> class_getClassVariable ( <span class="type">Class</span> cls, const char *name );</span><br><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line">objc_property_t class_getProperty ( <span class="type">Class</span> cls, const char *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="type">Method</span> class_getInstanceMethod ( <span class="type">Class</span> cls, <span class="type">SEL</span> name );</span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="type">Method</span> class_getClassMethod ( <span class="type">Class</span> cls, <span class="type">SEL</span> name );</span><br><span class="line"><span class="comment">// 获取方法的具体实现</span></span><br><span class="line"><span class="type">IMP</span> class_getMethodImplementation ( <span class="type">Class</span> cls, <span class="type">SEL</span> name );</span><br><span class="line"><span class="type">IMP</span> class_getMethodImplementation_stret ( <span class="type">Class</span> cls, <span class="type">SEL</span> name );</span><br><span class="line"></span><br><span class="line">&gt; copy: 成员变量列表；属性列表；方法列表；协议列表；</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line"><span class="type">Ivar</span> * class_copyIvarList ( <span class="type">Class</span> cls, unsigned int *outCount );</span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">objc_property_t * class_copyPropertyList ( <span class="type">Class</span> cls, unsigned int *outCount );</span><br><span class="line"><span class="comment">// 获取所有方法的列表</span></span><br><span class="line"><span class="type">Method</span> * class_copyMethodList ( <span class="type">Class</span> cls, unsigned int *outCount );</span><br><span class="line"><span class="comment">// 获取类实现的协议列表</span></span><br><span class="line"><span class="type">Protocol</span> * class_copyProtocolList ( <span class="type">Class</span> cls, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
<p>b、 操作函数:</p>
<p>method_：<br>invoke: 方法实现的返回值；<br>// 调用指定方法的实现<br>id method_invoke ( id receiver, Method m, … );</p>
<p>// 调用返回一个数据结构的方法的实现<br>void method_invoke_stret ( id receiver, Method m, … );<br>get: 方法名；方法实现；参数与返回值相关；</p>
<p>// 获取方法名<br>SEL method_getName ( Method m );</p>
<p>// 返回方法的实现<br>IMP method_getImplementation ( Method m );<br>// 获取描述方法参数和返回值类型的字符串<br>const char <em> method_getTypeEncoding ( Method m );<br>// 返回方法的参数的个数<br>unsigned int method_getNumberOfArguments ( Method m );<br>// 通过引用返回方法指定位置参数的类型字符串<br>void method_getArgumentType ( Method m, unsigned int index, char </em>dst, size_t dst_len );<br>copy: 返回值类型，参数类型</p>
<p>// 获取方法的返回值类型的字符串<br>char * method_copyReturnType ( Method m );</p>
<p>// 获取方法的指定位置参数的类型字符串<br>char * method_copyArgumentType ( Method m, unsigned int index );</p>
<p>// 通过引用返回方法的返回值类型字符串<br>void method_getReturnType ( Method m, char *dst, size_t dst_len );<br>set：方法实现；</p>
<p>// 设置方法的实现<br>IMP method_setImplementation ( Method m, IMP imp );<br>exchange：交换方法实现</p>
<p>// 交换两个方法的实现<br>void method_exchangeImplementations ( Method m1, Method m2 );<br>description : 方法描述</p>
<p>// 返回指定方法的方法描述结构体<br>struct objc_method_description <em> method_getDescription ( Method m );<br>sel_<br>// 返回给定选择器指定的方法的名称<br>const char </em> sel_getName ( SEL sel );</p>
<p>// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器<br>SEL sel_registerName ( const char *str );</p>
<p>// 在Objective-C Runtime系统中注册一个方法<br>SEL sel_getUid ( const char *str );</p>
<p>// 比较两个选择器<br>BOOL sel_isEqual ( SEL lhs, SEL rhs );<br>c、方法调用流程：向对象发送消息，实际上是调用objc_msgSend函数，obj_msgSend的实际动作就是：找到这个函数指针，然后调用它。</p>
<p>id objc_msgSend(receiver self, selector _cmd, arg1, arg2, …)<br>self和_cmd是隐藏参数，在编译期被插入实现代码。<br>self：指向消息的接受者target的对象类型，作为一个占位参数，消息传递成功后self将指向消息的receiver。<br>_cmd: 指向方法实现的SEL类型。</p>
<p>当向一般对象发送消息时，调用objc_msgSend；当向super发送消息时，调用的是objc_msgSendSuper； 如果返回值是一个结构体，则会调用objc_msgSend_stret或objc_msgSendSuper_stret。</p>
<p>0.1-检查target是否为nil。如果为nil，直接cleanup，然后return。(这就是我们可以向nil发送消息的原因。)<br>如果方法返回值是一个对象，那么发送给nil的消息将返回nil；如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void<em>)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0；如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0；如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。<br>0.2-如果target非nil，在target的Class中根据Selector去找IMP。（因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现）。<br>1-首先它找到selector对应的方法实现:
</em>1.1-在target类的方法缓存列表里检查有没有对应的方法实现，有的话，直接调用。<br><em>1.2-比较请求的selector和类方法列表中的selector，对应的话，直接调用。
</em>1.3-比较请求的selector和父类方法列表，父类的父类，直至根类，如果有对应，则直接调用。（方法重写拦截父类方法的原理）<br>2-调用方法实现，并将接收者对象及方法的所有参数传给它。<br>3-最后，将实现函数的返回值作为自己的返回值。</p>
<p>d、动态方法解析与消息转发：如果以上的类中没有找到对应的selector（一般保险起见先用respondsToSelector:内省判断）：，还可以利用消息转发机制依次执行以下流程：</p>
<p>Method Resolution（动态方法解析）：<br>用所属类的类方法+（BOOL）resolveInstanceMethod:(实例方法)或者+（BOOL）resolveClassMethod:(类方法),在此方法里添加class_addMethod函数。一般用于@dynamic动态属性。（当一个属性声明为@dynamic，就是向编译器保证编译时不用管/get实现，一定会在运行时实现）。<br>Fast Forwarding （快速消息转发）：<br>如果上一步无法响应消息，调用- (id)forwardingTargetForSelector:(SEL)aSelector方法，将消息接受者转发到另一个对象target（不能为self，否则死循环）。</p>
<p>Normal Forwarding（普通消息转发）：<br>如果上一步无法响应消息：<br>调用方法签名- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector，方法签名目的将函数的参数类型和返回值封装；<br>如果返回非nil，则创建一个NSInvocation对象利用方法签名和selector封装未被处理的消息，作为参数传递给- (void)forwardInvocation:(NSInvocation )anInvocation。<br>这一步比较耗时。</p>
<p>如果以上步骤（消息传递和消息转发）还是不能响应消息，则调动doesNotRecognizeSelector：方法，抛出异常。</p>
<p>unrecognized selector sent to instance<br>(消息转发可以利用转移消息接受对象，实现伪多重继承的效果。)</p>
<p>4、 协议相关：@protocol声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。<br>数据类型：Protocol；</p>
<p>typedef struct objc_object Protocol;<br>protocol是一个对象结构体。</p>
<p>操作函数：</p>
<p>objc_:<br>// 返回指定的协议<br>Protocol <em> objc_getProtocol ( const char </em>name );</p>
<p>// 获取运行时所知道的所有协议的数组<br>Protocol *<em> objc_copyProtocolList ( unsigned int </em>outCount );</p>
<p>// 创建新的协议实例<br>Protocol <em> objc_allocateProtocol ( const char </em>name );</p>
<p>// 在运行时中注册新创建的协议<br>void objc_registerProtocol ( Protocol <em>proto );<br>protocol_：<br>get: 协议；属性；<br>// 返回协议名<br>const char </em> protocol_getName ( Protocol <em>p );<br>// 获取协议的指定属性<br>objc_property_t protocol_getProperty ( Protocol </em>proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );<br>copy：协议列表；属性列表；</p>
<p>// 获取协议中的属性列表<br>objc_property_t <em> protocol_copyPropertyList ( Protocol </em>proto, unsigned int <em>outCount );<br>// 获取协议采用的协议<br>Protocol ** protocol_copyProtocolList ( Protocol </em>proto, unsigned int *outCount );<br>add：属性；方法；协议；</p>
<p>// 为协议添加方法<br>void protocol_addMethodDescription ( Protocol <em>proto, SEL name, const char </em>types, BOOL isRequiredMethod, BOOL isInstanceMethod );</p>
<p>// 添加一个已注册的协议到协议中<br>void protocol_addProtocol ( Protocol <em>proto, Protocol </em>addition );</p>
<p>// 为协议添加属性<br>void protocol_addProperty ( Protocol <em>proto, const char </em>name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );<br>isEqual：判断两协议等同；</p>
<p>// 测试两个协议是否相等<br>BOOL protocol_isEqual ( Protocol <em>proto, Protocol </em>other );<br>comform：判断是否遵循协议；</p>
<p>// 查看协议是否采用了另一个协议<br>BOOL protocol_conformsToProtocol ( Protocol <em>proto, Protocol </em>other );<br>5、 其他：类名；版本号；类信息；（忽略）<br>三、 动态实现：</p>
<p>Method Swizzling;<br>Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。通常应用于在category中添加一个方法。<br>为保证改变方法引起冲突，确保方法混用只能一次性：<br>比如，在+load方法或者dispatch_once中执行。<br>ISA Swizzling；<br>ISA Swizzling可以动态修改对象的isa指针，改变对象的类，类似于创建子类实现相同的功能。KVO即是同过ISA Swizzling实现的。<br>四、 其他概念：category；super；<br>category:<br>typedef struct objc_category *Category;</p>
<p>struct objc_category {<br>    char <em>category_name                          OBJC2_UNAVAILABLE; // 分类名<br>    char </em>class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名<br>    struct objc_method_list <em>instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表<br>    struct objc_method_list </em>class_methods       OBJC2_UNAVAILABLE; // 类方法列表<br>    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表<br>}  </p>
<p>// objc-runtime-new.h中定义：<br>struct category_t {<br>    const char <em>name;                        // name 是指 class_name 而不是 category_name<br>    classref_t cls;                          // cls是要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象<br>    struct method_list_t </em>instanceMethods;<br>    struct method_list_t <em>classMethods;<br>    struct protocol_list_t </em>protocols;<br>    struct property_list_t *instanceProperties;    // instanceProperties表示Category里所有的properties，(这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，)不过这个和一般的实例变量是不一样的</p>
<p>};<br>category就是定义方法的结构体，instance_methods列表是objc_class中方法列表的一个子集，class_methods列表是元类方法列表的一个子集。由其结构成员可知，category为什么不能添加成员变量（可添加属性，只有set/get方法）。</p>
<p>给category添加方法后，category_list会生成method list。这个方法列表是倒序添加的，也就是说，新生成的category的方法会先于旧的category的方法插入。（category的方法会优先于类方法执行）。</p>
<p>super：<br>super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，跳过当前类去调用父类的方法，而不是本类中的方法。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。实际上给super发消息时，super还是与self指向的是相同的消息接收者。</p>
<p>struct objc_super {<br>   <strong>unsafe_unretained id receiver;
   </strong>unsafe_unretained Class super_class;<br>};<br>原理：使用super来接收消息时，编译器会生成一个objc_super结构体。发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数:</p>
<p>id objc_msgSendSuper ( struct objc_super *super, SEL op, … );<br>该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找selector，找到后以objc-&gt;receiver去调用这个selector。</p>
<p>Runtime开源源码对一些方法的实现：</p>
<ul>
<li><p>(Class)class ;</p>
</li>
<li><p>(Class)class {<br>  return object_getClass(self);<br>}</p>
</li>
</ul>
<ul>
<li><p>(Class)class;</p>
</li>
<li><p>(Class)class {<br>  return self;<br>}</p>
</li>
</ul>
<ul>
<li><p>(BOOL)isKindOf:aClass;// (for循环遍历父类，每次判断返回的结果可能不同)</p>
</li>
<li><p>(BOOL)isKindOf:aClass<br>{<br>  Class cls;<br>  for (cls = isa; cls; cls = cls-&gt;superclass) </p>
<pre><code>if (cls == (Class)aClass)
    return YES;
</code></pre><p>  return NO;<br>}</p>
</li>
<li><p>(BOOL)isMemberOf:aClass;</p>
</li>
<li><p>(BOOL)isMemberOf:aClass<br>{<br>  return isa == (Class)aClass;<br>}</p>
</li>
</ul>
<p>文／楚天舒（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/f900de4a1495" target="_blank" rel="noopener">http://www.jianshu.com/p/f900de4a1495</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/Runtime_OC/" data-id="cjjs94x2g005o9t53uy0dgx31" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/webview 注入图片点击js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/webview 注入图片点击js/" class="article-date">
  <time datetime="2018-07-18T09:57:26.461Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/webview 注入图片点击js/">webview 注入图片点击js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>在网页加载完成时，通过js获取图片和添加点击的识别方式<br><code>`</code>swift</p>
<ul>
<li>(void)webViewDidFinishLoad:(UIWebView *)webView {<br>  [IDProgressHUD IDPlaceViewHideDirect:self.view];</li>
</ul>
</blockquote>
<pre><code>//这里是js，主要目的实现对url的获取
static  NSString * const jsGetImages =
@&quot;function getImages(){\
var objs = document.getElementsByTagName(\&quot;img\&quot;);\
var imgScr = &apos;&apos;;\
for(var i=0;i&lt;objs.length;i++){\
imgScr = imgScr + objs[i].src + &apos;+&apos;;\
};\
return imgScr;\
};&quot;;

[webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法
NSString *urlResurlt = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;];
mUrlArray = [NSMutableArray arrayWithArray:[urlResurlt componentsSeparatedByString:@&quot;+&quot;]];
if (mUrlArray.count &gt;= 2) {
    [mUrlArray removeLastObject];
}
//urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组

//添加图片可点击js
[mWebView stringByEvaluatingJavaScriptFromString:@&quot;function registerImageClickAction(){\
 var imgs=document.getElementsByTagName(&apos;img&apos;);\
 var length=imgs.length;\
 for(var i=0;i&lt;length;i++){\
 img=imgs[i];\
 img.onclick=function(){\
 window.location.href=&apos;image-preview:&apos;+this.src}\
 }\
 }&quot;];
[mWebView stringByEvaluatingJavaScriptFromString:@&quot;registerImageClickAction();&quot;];
</code></pre><p>}</p>
<p>//在这个方法中捕获到图片的点击事件和被点击图片的url</p>
<ul>
<li><p>(BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>
<p>  //预览图片<br>  if ([request.URL.scheme isEqualToString:@”image-preview”]) {</p>
<pre><code>NSString* path = [request.URL.absoluteString substringFromIndex:[@&quot;image-preview:&quot; length]];
path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
//path 就是被点击图片的url
return NO;
</code></pre><p>  }<br>  return YES;<br>}</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/webview 注入图片点击js/" data-id="cjjs94x1g004k9t534o5v0uac" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/iOS开发笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/iOS开发笔记/" class="article-date">
  <time datetime="2018-07-18T09:57:26.460Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/iOS开发笔记/">iOS开发笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>1，pod安装更改源</p>
<p>cocoapods卸载与安装的各种坑<br><a href="http://www.cnblogs.com/hankkk/p/5703050.html" target="_blank" rel="noopener">http://www.cnblogs.com/hankkk/p/5703050.html</a></p>
<blockquote>
<p>1，pod 安装源过慢<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod repo remove master</span><br><span class="line">pod repo add master https:<span class="comment">//git.coding.net/CocoaPods/Specs.git</span></span><br><span class="line">git clone https:<span class="comment">//git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master</span></span><br><span class="line">pod repo update</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>iOS开发－关闭/收起键盘方法总结<br>前言：作为IOS开发人员，需要经常和表单打交道。因此我对收起键盘的方法作了下总结，IOS收起键盘有三种方法（如果有其它收起键盘的方法请在留言区指错）。</p>
<p>收起键盘的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、点击Return按扭时收起键盘</span><br><span class="line"></span><br><span class="line">- (BOOL)textFieldShouldReturn: (UITextField *)textField</span><br><span class="line">&#123;</span><br><span class="line">    return [textField resignFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2、点击背景View收起键盘（你的View必须是继承于UIControl）</span><br><span class="line"></span><br><span class="line">[self.view endEditing:YES];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3、你可以在任何地方加上这句话，可以用来统一收起键盘</span><br><span class="line"></span><br><span class="line">[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</span><br><span class="line">这个方法是我不久前碰到的，觉得有用，就记下来了。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4. 还有一个方法是直接发送 resignFirstResponder 消息：</span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] sendAction: @selector(resignFirstResponder) to:nil from:nil forEvent:nil];</span><br></pre></td></tr></table></figure></p>
<p>3.Swift 中的指针使用<br><a href="https://onevcat.com/2015/01/swift-pointer/" target="_blank" rel="noopener">https://onevcat.com/2015/01/swift-pointer/</a></p>
<p>Apple 期望在 Swift 中指针能够尽量减少登场几率，因此在 Swift 中指针被映射为了一个泛型类型，并且还比较抽象。这在一定程度上造成了在 Swift 中指针使用的困难，特别是对那些并不熟悉指针，也没有多少指针操作经验的开发者 (包括我自己也是) 来说，在 Swift 中使用指针确实是一个挑战。在这篇文章里，我希望能从最基本的使用开始，总结一下在 Swift 中使用指针的一些常见方式和场景。这篇文章假定你至少知道指针是什么，如果对指针本身的概念不太清楚的话，可以先看看这篇五分钟 C 指针教程 (或者它的中文版本)，应该会很有帮助。</p>
<p>初步</p>
<p>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 UnsafePointer<t>。遵循了 Cocoa 的一贯不可变原则，UnsafePointer<t> 也是不可变的。当然对应地，它还有一个可变变体，UnsafeMutablePointer<t>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 UnsafePointer (最常见的应该就是 C 字符串的 const char * 了)，而其他可变的指针则对应 UnsafeMutablePointer。除此之外，Swift 中存在表示一组连续数据指针的 UnsafeBufferPointer<t>，表示非完整结构的不透明指针 COpaquePointer 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。</t></t></t></t></p>
<p>对于一个 UnsafePointer<t> 类型，我们可以通过 memory 属性对其进行取值，如果这个指针是可变的 UnsafeMutablePointer<t> 类型，我们还可以通过 memory 对它进行赋值。比如我们想要写一个利用指针直接操作内存的计数器的话，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func incrementor(ptr: UnsafeMutablePointer&lt;Int&gt;) &#123;</span><br><span class="line">    ptr.memory += 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 10</span><br><span class="line">incrementor(&amp;a)</span><br><span class="line"></span><br><span class="line">a  // 11</span><br></pre></td></tr></table></figure></t></t></p>
<p>这里和 C 的指针使用类似，我们通过在变量名前面加上 &amp; 符号就可以将指向这个变量的指针传递到接受指针作为参数的方法中去。在上面的 incrementor 中我们通过直接操作 memory 属性改变了指针指向的内容。</p>
<p>与这种做法类似的是使用 Swift 的 inout 关键字。我们在将变量传入 inout 参数的函数时，同样也使用 &amp; 符号表示地址。不过区别是在函数体内部我们不需要处理指针类型，而是可以对参数直接进行操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func incrementor1(inout num: Int) &#123;</span><br><span class="line">    num += 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = 10</span><br><span class="line">incrementor1(&amp;b)</span><br><span class="line"></span><br><span class="line">b  // 11</span><br></pre></td></tr></table></figure></p>
<p>虽然 &amp; 在参数传递时表示的意义和 C 中一样，是某个“变量的地址”，但是在 Swift 中我们没有办法直接通过这个符号获取一个 UnsafePointer 的实例。需要注意这一点和 C 有所不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无法编译</span><br><span class="line">let a = 100</span><br><span class="line">let b = &amp;a</span><br><span class="line">指针初始化和内存管理</span><br></pre></td></tr></table></figure></p>
<p>在 Swift 中不能直接取到现有对象的地址，我们还是可以创建新的 UnsafeMutablePointer 对象。与 Swift 中其他对象的自动内存管理不同，对于指针的管理，是需要我们手动进行内存的申请和释放的。一个 UnsafeMutablePointer 的内存有三种可能状态：</p>
<p>内存没有被分配，这意味着这是一个 null 指针，或者是之前已经释放过<br>内存进行了分配，但是值还没有被初始化<br>内存进行了分配，并且值已经被初始化<br>其中只有第三种状态下的指针是可以保证正常使用的。UnsafeMutablePointer 的初始化方法 (init) 完成的都是从其他类型转换到 UnsafeMutablePointer 的工作。我们如果想要新建一个指针，需要做的是使用 alloc: 这个类方法。该方法接受一个 num: Int 作为参数，将向系统申请 num 个数的对应泛型类型的内存。下面的代码申请了一个 Int 大小的内存，并返回指向这块内存的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var intPtr = UnsafeMutablePointer&lt;Int&gt;.alloc(1)</span><br><span class="line">// &quot;UnsafeMutablePointer(0x7FD3A8E00060)&quot;</span><br><span class="line">接下来应该做的是对这个指针的内容进行初始化，我们可以使用 initialize: 方法来完成初始化：</span><br><span class="line"></span><br><span class="line">intPtr.initialize(10)</span><br><span class="line">// intPtr.memory 为 10</span><br><span class="line">在完成初始化后，我们就可以通过 memory 来操作指针指向的内存值了。</span><br><span class="line"></span><br><span class="line">在使用之后，我们最好尽快释放指针指向的内容和指针本身。与 initialize: 配对使用的 destroy 用来销毁指针指向的对象，而与 alloc: 对应的 dealloc: 用来释放之前申请的内存。它们都应该被配对使用：</span><br><span class="line"></span><br><span class="line">intPtr.destroy()</span><br><span class="line">intPtr.dealloc(1)</span><br><span class="line">intPtr = nil</span><br><span class="line">注意其实在这里对于 Int 这样的在 C 中映射为 int 的 “平凡值” 来说，destroy 并不是必要的，因为这些值被分配在常量段上。但是对于像类的对象或者结构体实例来说，如果不保证初始化和摧毁配对的话，是会出现内存泄露的。所以没有特殊考虑的话，不论内存中到底是什么，保证 initialize: 和 destroy 配对会是一个好习惯。</span><br><span class="line">指向数组的指针</span><br><span class="line"></span><br><span class="line">在 Swift 中将一个数组作为参数传递到 C API 时，Swift 已经帮助我们完成了转换，这在 Apple 的官方博客中有个很好的例子：</span><br><span class="line"></span><br><span class="line">import Accelerate</span><br><span class="line"></span><br><span class="line">let a: [Float] = [1, 2, 3, 4]</span><br><span class="line">let b: [Float] = [0.5, 0.25, 0.125, 0.0625]</span><br><span class="line">var result: [Float] = [0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">vDSP_vadd(a, 1, b, 1, &amp;result, 1, 4)</span><br><span class="line"></span><br><span class="line">// result now contains [1.5, 2.25, 3.125, 4.0625]</span><br><span class="line">对于一般的接受 const 数组的 C API，其要求的类型为 UnsafePointer，而非 const 的数组则对应 UnsafeMutablePointer。使用时，对于 const 的参数，我们直接将 Swift 数组传入 (上例中的 a 和 b)；而对于可变的数组，在前面加上 &amp; 后传入即可 (上例中的 result)。</span><br><span class="line"></span><br><span class="line">对于传参，Swift 进行了简化，使用起来非常方便。但是如果我们想要使用指针来像之前用 memory 的方式直接操作数组的话，就需要借助一个特殊的类型：UnsafeMutableBufferPointer。Buffer Pointer 是一段连续的内存的指针，通常用来表达像是数组或者字典这样的集合类型。</span><br><span class="line"></span><br><span class="line">var array = [1, 2, 3, 4, 5]</span><br><span class="line">var arrayPtr = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count)</span><br><span class="line">// baseAddress 是第一个元素的指针</span><br><span class="line">var basePtr = arrayPtr.baseAddress as UnsafeMutablePointer&lt;Int&gt;</span><br><span class="line"></span><br><span class="line">basePtr.memory // 1</span><br><span class="line">basePtr.memory = 10</span><br><span class="line">basePtr.memory // 10</span><br><span class="line"></span><br><span class="line">//下一个元素</span><br><span class="line">var nextPtr = basePtr.successor()</span><br><span class="line">nextPtr.memory // 2</span><br><span class="line">指针操作和转换</span><br><span class="line"></span><br><span class="line">withUnsafePointer</span><br><span class="line">上面我们说过，在 Swift 中不能像 C 里那样使用 &amp; 符号直接获取地址来进行操作。如果我们想对某个变量进行指针操作，我们可以借助 withUnsafePointer 这个辅助方法。这个方法接受两个参数，第一个是 inout 的任意类型，第二个是一个闭包。Swift 会将第一个输入转换为指针，然后将这个转换后的 Unsafe 的指针作为参数，去调用闭包。使用起来大概是这个样子：</span><br><span class="line"></span><br><span class="line">var test = 10</span><br><span class="line">test = withUnsafeMutablePointer(&amp;test, &#123; (ptr: UnsafeMutablePointer&lt;Int&gt;) -&gt; Int in</span><br><span class="line">    ptr.memory += 1</span><br><span class="line">    return ptr.memory</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test // 11</span><br></pre></td></tr></table></figure></p>
<p>这里其实我们做了和文章一开始的 incrementor 相同的事情，区别在于不需要通过方法的调用来将值转换为指针。这么做的好处对于那些只会执行一次的指针操作来说是显而易见的，可以将“我们就是想对这个指针做点事儿”这个意图表达得更加清晰明确。</p>
<p>unsafeBitCast<br>unsafeBitCast 是非常危险的操作，它会将一个指针指向的内存强制按位转换为目标的类型。因为这种转换是在 Swift 的类型管理之外进行的，因此编译器无法确保得到的类型是否确实正确，你必须明确地知道你在做什么。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = NSArray(object: &quot;meow&quot;)</span><br><span class="line">let str = unsafeBitCast(CFArrayGetValueAtIndex(arr, 0), CFString.self)</span><br><span class="line">str // “meow”</span><br></pre></td></tr></table></figure></p>
<p>因为 NSArray 是可以存放任意 NSObject 对象的，当我们在使用 CFArrayGetValueAtIndex 从中取值的时候，得到的结果将是一个 UnsafePointer<void>。由于我们很明白其中存放的是 String 对象，因此可以直接将其强制转换为 CFString。</void></p>
<p>关于 unsafeBitCast 一种更常见的使用场景是不同类型的指针之间进行转换。因为指针本身所占用的的大小是一定的，所以指针的类型进行转换是不会出什么致命问题的。这在与一些 C API 协作时会很常见。比如有很多 C API 要求的输入是 void *，对应到 Swift 中为 UnsafePointer<void>。我们可以通过下面这样的方式将任意指针转换为 UnsafePointer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var count = 100</span><br><span class="line">var voidPtr = withUnsafePointer(&amp;count, &#123; (a: UnsafePointer&lt;Int&gt;) -&gt; UnsafePointer&lt;Void&gt; in</span><br><span class="line">    return unsafeBitCast(a, UnsafePointer&lt;Void&gt;.self)</span><br><span class="line">&#125;)</span><br><span class="line">// voidPtr 是 UnsafePointer&lt;Void&gt;。相当于 C 中的 void *</span><br><span class="line"></span><br><span class="line">// 转换回 UnsafePointer&lt;Int&gt;</span><br><span class="line">var intPtr = unsafeBitCast(voidPtr, UnsafePointer&lt;Int&gt;.self)</span><br><span class="line">intPtr.memory //100</span><br></pre></td></tr></table></figure></void></p>
<p><a href="http://www.cocoachina.com/bbs/read.php?tid=307641" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid=307641</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//swfit oc 宏定义兼容写法</span><br><span class="line">extern NSString * const kPOPLayerBackgroundColor;</span><br><span class="line">extern NSString * const kPOPLayerBounds;</span><br><span class="line">extern NSString * const kPOPLayerCornerRadius;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<h4 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h4><p><code>`</code><br>关于nav过渡的解决方案：RTRootNavigationController，细节原理可参考 JTNavigationController</p>
<p><a href="https://github.com/rickytan/RTRootNavigationController" target="_blank" rel="noopener">https://github.com/rickytan/RTRootNavigationController</a><br><a href="https://github.com/roodkcab/HHNavigationController" target="_blank" rel="noopener">https://github.com/roodkcab/HHNavigationController</a><br><a href="https://github.com/DanisFabric" target="_blank" rel="noopener">https://github.com/DanisFabric</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/iOS开发笔记/" data-id="cjjs94x2a005i9t53qi7mhd6c" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS/WKWebView_OC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/iOS/WKWebView_OC/" class="article-date">
  <time datetime="2018-07-18T09:57:26.459Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/iOS/WKWebView_OC/">WKWebView_OC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h4><blockquote>
<p>设置 WKWebViewConfiguration 配置WKWebView的属性。</p>
</blockquote>
<blockquote>
<p>self.webView = [[WKWebView alloc] initWithFrame: self.view.bounds configuration:config];<br> // 通过JS与webview内容交互</p>
</blockquote>
<p>// 通过JS与webview内容交互<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config.userContentController = [[<span class="type">WKUserContentController</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注入JS对象名称AppModel，当JS通过AppModel来调用时，</span></span><br><span class="line"> <span class="comment">// 我们可以在WKScriptMessageHandler代理中接收到</span></span><br><span class="line"> </span><br><span class="line">[config.userContentController addScriptMessageHandler: <span class="keyword">self</span> name: @<span class="string">"AppModel"</span>];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导航代理</span></span><br><span class="line"><span class="keyword">self</span>.webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 与webview UI交互代理</span></span><br><span class="line"><span class="keyword">self</span>.webView.<span class="type">UIDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加KVO监听</span></span><br><span class="line">[<span class="keyword">self</span>.webView addObserver:<span class="keyword">self</span></span><br><span class="line">               forKeyPath:@<span class="string">"loading"</span></span><br><span class="line">                  options:<span class="type">NSKeyValueObservingOptionNew</span></span><br><span class="line">                  context:<span class="literal">nil</span>];</span><br><span class="line">[<span class="keyword">self</span>.webView addObserver:<span class="keyword">self</span></span><br><span class="line">               forKeyPath:@<span class="string">"title"</span></span><br><span class="line">                  options:<span class="type">NSKeyValueObservingOptionNew</span></span><br><span class="line">                  context:<span class="literal">nil</span>];</span><br><span class="line">[<span class="keyword">self</span>.webView addObserver:<span class="keyword">self</span></span><br><span class="line">               forKeyPath:@<span class="string">"estimatedProgress"</span></span><br><span class="line">                  options:<span class="type">NSKeyValueObservingOptionNew</span></span><br><span class="line">                  context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>#pragma mark - WKScriptMessageHandler<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)userContentController:(<span class="type">WKUserContentController</span> *)userContentController</span><br><span class="line">      didReceiveScriptMessage:(<span class="type">WKScriptMessage</span> *)message &#123;</span><br><span class="line">  <span class="keyword">if</span> ([message.name isEqualToString:@<span class="string">"AppModel"</span>]) &#123;</span><br><span class="line">    <span class="comment">// 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray,</span></span><br><span class="line">    <span class="comment">// NSDictionary, and NSNull类型</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, message.body);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - KVO<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(<span class="type">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(<span class="type">NSDictionary</span>&lt;<span class="type">NSString</span> *,id&gt; *)change</span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line">  <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"loading"</span>]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"loading"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"title"</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = <span class="keyword">self</span>.webView.title;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"estimatedProgress"</span>]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"progress: %f"</span>, <span class="keyword">self</span>.webView.estimatedProgress);</span><br><span class="line">    <span class="keyword">self</span>.progressView.progress = <span class="keyword">self</span>.webView.estimatedProgress;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 加载完成</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.webView.loading) &#123;</span><br><span class="line">    <span class="comment">// 手动调用JS代码</span></span><br><span class="line">    <span class="comment">// 每次页面完成都弹出来，大家可以在测试时再打开</span></span><br><span class="line">    <span class="type">NSString</span> *js = @<span class="string">"callJsAlert()"</span>;</span><br><span class="line">    [<span class="keyword">self</span>.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, <span class="type">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      <span class="type">NSLog</span>(@<span class="string">"response: %@ error: %@"</span>, response, error);</span><br><span class="line">      <span class="type">NSLog</span>(@<span class="string">"call js alert by native"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="type">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">      <span class="keyword">self</span>.progressView.alpha = <span class="number">0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Alexzzn.github.io/2018/07/18/iOS/WKWebView_OC/" data-id="cjjs94x0k003e9t535iccc3vw" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/19/Web/mysql/">mysql</a>
          </li>
        
          <li>
            <a href="/2018/07/19/Server/字符串/">字符串</a>
          </li>
        
          <li>
            <a href="/2018/07/19/Web/mysql基本语句/">mysql基本语句</a>
          </li>
        
          <li>
            <a href="/2018/07/18/iOS/java注解/">java注解</a>
          </li>
        
          <li>
            <a href="/2018/07/18/iOS/地图定位/">地图定位</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 zzn&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;youemail@outlook.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>